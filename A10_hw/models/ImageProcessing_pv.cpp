
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for ImageProcessing.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.2alpha1
//* Generated on: Feb. 15, 2016 11:27:19 AM, (user: vista)
//*>



#include "ImageProcessing_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

#define IWIDTH 352
#define IHEIGHT 288

//constructor
ImageProcessing_pv::ImageProcessing_pv(sc_module_name module_name) 
  : ImageProcessing_pv_base(module_name)
  ,mbFifo(1)
{
  SC_THREAD(thread);

}   


double ImageProcessing_pv::sRGB_to_linear(double x) {
    if (x < 0.04045) return x/12.92;
    return pow((x+0.055)/1.055, 2.4);
}

double ImageProcessing_pv::linear_to_sRGB(double y) {
    if (y <= 0.0031308) return 12.92 * y;
    return 1.055 * pow(y, 1/2.4) - 0.055;
}

void ImageProcessing_pv::getPixel(unsigned char* bmp, int x, int y, pixel_t* p)
{
  unsigned char* top = (bmp + SIZE) - (IHEIGHT * IWIDTH * 3);
  p->red = top[0 + ((y * IWIDTH + x) * 3)];
  p->green = top[1 + ((y * IWIDTH + x) * 3)];
  p->blue = top[2 + ((y * IWIDTH + x) * 3)];
}

void ImageProcessing_pv::setPixel(unsigned char* bmp, int x, int y, pixel_t* p)
{
  unsigned char* top = (bmp + SIZE) - (IHEIGHT * IWIDTH * 3);
  top[0 + ((y * IWIDTH + x) * 3)] = p->red;
  top[1 + ((y * IWIDTH + x) * 3)] = p->green;
  top[2 + ((y * IWIDTH + x) * 3)] = p->blue;
}


void ImageProcessing_pv::grayScale(pixel_t* p)
{
  double R_linear = sRGB_to_linear(p->red/255.0);
  double G_linear = sRGB_to_linear(p->green/255.0);
  double B_linear = sRGB_to_linear(p->blue/255.0);
  double gray_linear = 0.2126 * R_linear + 0.7152 * G_linear + 0.0722 * B_linear;
  double gray_color = round(linear_to_sRGB(gray_linear) * 255);
  p->red = gray_color;
  p->green = gray_color;
  p->blue = gray_color;
}


void ImageProcessing_pv::thread() {
  while(1) {
    mbFifo.peek(); // block/wait until start bit is written

    //    cout <<name()<<" @ "<<sc_time_stamp()<<" Processing Image " << endl;;

    //    cout <<name()<<" @ "<<sc_time_stamp()<<" Reading data from " << SOURCE << endl;
    unsigned char *b = (unsigned char*) malloc(SIZE + 1);
    master_read(SOURCE , b, SIZE);

    unsigned char *d = (unsigned char*) malloc(SIZE + 1);

    pixel_t p;
    int i, j, x, y;
    int res = 8;
    for (y = 0; y < IHEIGHT; y+=res) {
      for(x = 0; x < IWIDTH; x+=res) {
        getPixel(b, x, y, &p);
        grayScale(&p);
        for(i = 0; i < res; i++) {
          for(j = 0; j < res; j++) {
            setPixel(d, x+i, y+j, &p);
          }
        }
      }
    }

    //    cout <<name()<<" @ "<<sc_time_stamp()<<" Writing data to " << TARGET << endl;
    master_write(TARGET , d, SIZE);

    free(b);
    free(d);

    //    cout <<name()<<" @ "<<sc_time_stamp()<<" Triggering irq" << endl;
    irq.write(1);
    mbFifo.get();  // release Fifo, Done.
  }
}



/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a 
// write event on one of the registers as defined in the Model Builder form.
// These functions are called before the write callbacks on the port.
///////////////////////////////////////////////////////////////////////////////// 

#define CHECK_BIT(var,pos) ((var) & (1<<(pos)))

// Write callback for CONTROL register.
// The newValue has been already assigned to the CONTROL register.
void ImageProcessing_pv::cb_write_CONTROL(unsigned long long newValue) {
  if (CHECK_BIT(CONTROL, 0)) {
    //    cout <<name()<<" @ "<<sc_time_stamp()<<" CONTROL start bit = 1" << endl;
    mbFifo.put(1);
  }
  else {
    //    cout <<name()<<" @ "<<sc_time_stamp()<<" CONTROL start bit = 0, resetting irq" << endl;
    irq.write(0);
  }
}
    
// Read callback for slave port.
// Returns true when successful.
bool ImageProcessing_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

// Write callback for slave port.
// Returns true when successful.
bool ImageProcessing_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
} 




unsigned ImageProcessing_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned ImageProcessing_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool ImageProcessing_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

 
void ImageProcessing_pv::cb_transport_dbg_CONTROL(tlm::tlm_generic_payload& trans) {}
